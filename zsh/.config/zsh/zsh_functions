
function bb(){
  local declare dirs=()

  get_parent_dirs() {
    current_path="$1"
    while [[ "$current_path" != '/' ]]; do
      # next parent dir ignoring the first and current one
      current_path="$(dirname "$current_path")"
      if [[ -d "$current_path" ]]; then dirs+=("$current_path"); fi
    done
    printf "%s\n" "${dirs[@]}"
  }

  # Show all possible parents paths
  # Remove the current path
  # Count paths to easily select them from fzf
  # Finally remove the added index and cd to the selected parent path
  local DIR=$(get_parent_dirs "$(realpath "${1:-$PWD}")" | nl --starting-line-number 1 | fzf | cut -f2)
  cd "$DIR"
}

function p() {
  if [ $# -eq 0 ]; then
    fzf --multi --bind "enter:execute(bat --color always {+})+abort" --preview "bat --color always {}"
  else
    bat --color always "$@"
  fi;
}


function mc() {
  mkdir --parent --verbose "$1" && cd "$1"
}

function ll() {
  if [ -n "$1" ]; then
    l --tree "$1" | bat --number
  else
    l --tree | bat --number
  fi
}

# cd to the clipboard path
function cdp() {
  clipboard_path=$(xclip -out -selection clipboard)
  [[ -d "$clipboard_path" ]] && cd "$clipboard_path" || echo "\e[31mClipboard doesn't containt a folder path!\e[39m"
}


# translation functions {{{
function te () {
  # Use command to avoid recursion
  # Use "$*" instead -join-sentence "$@"
  # Remove spaces at beginning of the translated input
  # Copy the translated input to the system clipboard
  command trans -brief -no-ansi "$*" | tail --lines 1 | sed 's/^\s*//' | cb
}
# Force to never save in the shell history the translations (beginning with space)
alias te=" te"

function ts () {
  # Use command to avoid recursion
  # Use "$*" instead -join-sentence "$@"
  # Remove spaces at beginning of the translated input
  # Copy the translated input to the system clipboard
  command trans ':es' -brief -no-ansi "$*" | tail --lines 1 | sed 's/^\s*//' | cb
}
# Force to never save in the shell history the translations (beginning with space)
alias ts=" ts"

function tf () {
  # Use command to avoid recursion
  # Use "$*" instead -join-sentence "$@"
  # Remove spaces at beginning of the translated input
  # Copy the translated input to the system clipboard
  command trans ':fr' -brief -no-ansi "$*" | tail --lines 1 | sed 's/^\s*//' | cb
}
# Force to never save in the shell history the translations (beginning with space)
alias tf=" tf"
# }}}

# cb STRING to copy to the clipboard
# cb FILE to copy to the clipboard
# echo string | cb to copy to the clipboard
# cb to paste from the clipboard
# cb | command to paste from the clipboad
function cb () {
  # stdin is a pipe
  if [[ -p /dev/stdin ]] ; then
    # stdin -> clipboard
    xclip -selection clipboard -in
  # stdin is not a pipe
  elif [[ ! -z "$1" ]]; then
    if [[ -f "$1" ]]; then
      # file -> clipboard
      xclip -selection clipboard -in "$1"
    else
      # string -> clipboard
      echo "$*" | xclip -selection clipboard -in
    fi
  else
    # clipboard -> stdout
    # no arguments were passed
    # xclip -selection clipboard -out
  fi
    xclip -selection clipboard -out
}

# Burn image files to USB
function iso()  {
  sudo umount $2 2> /dev/null
  sudo dd bs=4M if=$1 of=$2 status=progress conv=fdatasync
}

# o function and open function with handlr {{{
# It works better than xdg-open in i3-wm and also it provides a better and nicer terminal interface than their xdg-utils equivalents
function open() {
  # handlr can open multiple files at the same time without the explict loop
  # but with a loop it's better to set nohup each std and err outputs independently
  # to check faster if a file is not running fine
  for file in "$@"
  do
    # Run handlr with nohup in background and remove it from the jobs table
     nohup handlr open "$file" >| /tmp/nohup-"$(basename $file)".out 2>| /tmp/nohup-"$(basename $file)".err < /dev/null &
    disown %%
  done
}
# If o doesn't have any argument, open the current dir
function o() {
  if [ $# -eq 0 ]; then
    vifm .;
  else
    open "$@";
  fi;
}
# }}}

function python () {
  # stdin is a pipe
  if [[ -p /dev/stdin ]]; then
    command python "$@"
  else
  # Use command to avoid the recursion
  test -z "$1" && ptpython || command python "$@"
  fi
}

function R () {
  # stdin is a pipe
  if [[ -p /dev/stdin ]]; then
    command R "$@"
else
  # Use command to avoid the recursion
  test -z "$1" && radian || command R "$@"
  fi
}

function ff () {
  firefox --private-window https://www.google.com/search?q="$1" &
}
# Never save firefox searches in the history
alias ff=' ff'


# " Reduce PDF size by lossy recompressing with Ghostscript"
# " Not guaranteed to succeed, but usually works"
# " Usage: file.pdf [resolution_in_dpi]"
# https://bash.cyberciti.biz/file-management/linux-shell-script-to-reduce-pdf-file-size
function pdfc () {
  echo $@ | xargs -d' ' -n 1 -P 0 -I{} zsh -ic '_pdfc {}'
}
function _pdfc () {
  if [ -z "$1" ]; then
    echo "Usage: file.pdf [resolution_in_dpi]"
    return 1
  fi
  if [ -n "$2" ]; then
    resolution="$2"
  else
    resolution="90"
  fi
  pdf="$1"

  original_pdf=${pdf%.pdf}_original.pdf

  mv "$pdf" "$original_pdf"

  gs \
    -q -dNOPAUSE -dBATCH -dSAFER \
    -sDEVICE=pdfwrite \
    -dCompatibilityLevel=1.3 \
    -dPDFSETTINGS=/screen \
    -dEmbedAllFonts=true \
    -dSubsetFonts=true \
    -dAutoRotatePages=/None \
    -dColorImageDownsampleType=/Bicubic \
    -dColorImageResolution="$resolution" \
    -dGrayImageDownsampleType=/Bicubic \
    -dGrayImageResolution="$resolution" \
    -dMonoImageDownsampleType=/Subsample \
    -dMonoImageResolution="$resolution" \
    -sOutputFile="$pdf" \
    "$original_pdf"

  if [[ $? == 0 ]] then;
    pdf_size=$(wc -c "$pdf" | cut -f1 -d' ' )
    original_pdf_size=$(wc -c "$original_pdf" | cut -f1 -d' ')
    if [[ "$original_pdf_size" -le "$pdf_size" ]]; then
      >&2 echo "'$pdf' can't be compressed!"
      mv "$original_pdf" "$pdf"
    else
      compression_ration=$(awk "BEGIN{printf \"%0.2f\", $original_pdf_size/$pdf_size}")
      >&2 echo "$pdf"
      >&2 echo "\tCompression ration: $compression_ration"
      >&2 echo "\tFinal size: $(du -h $pdf | cut -f1)"
    fi
  else
    >&2 echo "'$pdf' can't be processed!"
  fi
}

# Extract any kind of compressed files list
function e () {
files=( "$@" )
for file in "${files[@]}"; do
  case $file in
    *.tar)            tar xvf $file;;
    *.tar.gz|*.tgz)   tar -I pigz -xvf $file;;
    *.tar.xz|*.txz)   tar -I pixz -xvf $file;;
    *.tar.bz2|*.tbz2) tar -I pbzip2 -xvf $file;;
    *.tar.zst|*.tzst) tar -I zstdmt -xvf $file;;
    *.bz2)            pbzip2 -dkv $file;;
    *.xz)             pixz -dk $file;;
    *.gz)             pigz -dkv $file;;
    *.zst)            zstdmt -dkv $file;;
    *.zip)            unzip $file;;
    *.7z)             7z x $file;;
    *.Z)              uncompress $file;;
    *.rar)            unrar e $file;;
    *)                >&2 echo "'$file' cannot be extracted, unknown compression format";;
  esac
done
}

# Compress any kind of files list
function c () {
  files=( "$@" )
  compression_format="${@: -1}"
  unset "files[${#files[@]}]"    # Removes last element -- also see: help unset
  for file in "${files[@]}"; do
    case $compression_format in
      t)  tar cvf ${file}.tar $file; ext='tar';;
      z)  zip -r ${file}.zip $file; ext='zip';;
      7)  7z a ${file}.7z $file; ext='7z';;
      g)  [[ -d $file ]] && tar -I pigz -cvf ${file}.tar.gz $file || pigz -kv $file; ext='gz';;
      b)  [[ -d $file ]] && tar -I pbzip2 -cvf ${file}.tar.bz2 $file || pbzip2 -kv $file; ext='bz2';;
      x)  [[ -d $file ]] && tar -I pixz -cvf ${file}.tar.xz $file || pixz -k $file; ext='xz';;
      zs) [[ -d $file ]] && tar -I 'zstdmt -19' -cvf ${file}.tar.zst $file || zstdmt -19 -kv $file; ext='zst';;
      *)  >&2 echo "'$file' cannot be compressed, unknown '$2' compression format" && return 1
    esac
    compressed_file="${file}*.${ext}"
    # force glob completion with $~
    compressed_size=$(command du $~compressed_file | cut -f1)
    original_size=$(command du -s "$1" | cut -f1)
    >&2 echo $~compressed_file
    compression_ration=$(awk "BEGIN{printf \"%0.2f\", $original_size/$compressed_size}")
    >&2 echo "\tCompression ration: $compression_ration"
    >&2 echo "\tFinal size: $(command du -h $~compressed_file | cut -f1)"
  done
}

# Tar wrapper
function t {
tar cpf "$1.tar" "$1"
}
