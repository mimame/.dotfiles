#!/usr/bin/env ruby
# frozen_string_literal: true

# update-mimeapps.rb
#
# This script generates a `~/.config/mimeapps.list` file based on a user-defined
# set of defaults and a system-wide scan of available applications.
#
# It ensures the user's preferred defaults are always enforced, preventing them
# from being overwritten by system updates or other applications.
#
# Features:
# - Reads preferred defaults from a simple YAML config file.
# - Supports wildcards (e.g., "image/*") for broad category defaults.
# - Supports specific overrides for fine-grained control.
# - Scans the system for all available .desktop files and their mimetypes.
# - Self-cleans the defaults.yaml file by removing entries for uninstalled apps.
# - Generates a clean `mimeapps.list` with [Default Applications] and
#   [Added Associations] sections.

require 'set'
require 'find'
require 'yaml'

# --- Configuration ---

# The user's source of truth for default applications.
DEFAULTS_PATH = File.expand_path('../mimeapps/defaults.yaml', __dir__)

# The final output file that desktop environments will use.
MIMEAPPS_OUTPUT_PATH = File.expand_path('~/.config/mimeapps.list')

# We only search the Nix store to ensure all applications are declaratively managed.
SEARCH_PATHS = [
  '/nix/store'
].freeze

# This module provides helper methods for formatting the output of the mimeapps.list file.
module MimeappsOutputFormatter
  private

  def _generate_header
    header = []
    header << '# This file is auto-generated by the update-mimeapps.rb script.'
    header << '# Do not edit directly. Your defaults are managed in:'
    header << "# #{DEFAULTS_PATH}\n\n"
    header.join("\n")
  end

  def _generate_default_applications_section(final_defaults)
    section = []
    section << '[Default Applications]'
    final_defaults.sort.to_h.each do |mime, app|
      section << "#{mime}=#{app}"
    end
    section.join("\n")
  end

  def _generate_added_associations_section(mimetype_to_apps)
    section = []
    section << '[Added Associations]'
    mimetype_to_apps.sort.to_h.each do |mime, apps|
      section << "#{mime}=#{apps.to_a.sort.join(';')};"
    end
    section.join("\n")
  end
end

# --- Main Class ---

# MimeappsGenerator
# This class is responsible for generating the `mimeapps.list` file.
class MimeappsGenerator
  include MimeappsOutputFormatter

  def initialize
    @mimetype_to_apps = Hash.new { |h, k| h[k] = Set.new }
    @available_apps = Set.new
    @exact_defaults = {}
    @wildcard_defaults = {}
    @final_defaults = {}
  end

  def run
    puts 'ðŸš€ Starting mimeapps.list generation...'

    scan_desktop_files
    clean_user_defaults
    load_user_defaults
    resolve_defaults
    write_output

    puts "âœ… Successfully generated #{MIMEAPPS_OUTPUT_PATH}"
  end

  private

  def scan_desktop_files
    puts 'ðŸ” Scanning for .desktop files in the Nix store...'
    SEARCH_PATHS.each do |search_path|
      next unless Dir.exist?(search_path)

      Find.find(search_path) do |path|
        _process_desktop_file(path)
      end
    end
    puts "   Found #{@mimetype_to_apps.keys.length} unique mimetypes from #{@available_apps.length} applications."
  end

  def _process_desktop_file(path)
    # Ensure we only process actual files, not directories that end in .desktop
    return unless path.end_with?('.desktop') && File.file?(path)

    content = File.read(path)
    return if content.include?('NoDisplay=true')

    mimetypes = _extract_mimetypes(content)
    return if mimetypes.empty?

    app_name = File.basename(path)
    @available_apps.add(app_name)

    mimetypes.each do |mime|
      @mimetype_to_apps[mime].add(app_name)
    end
  end

  def _extract_mimetypes(content)
    mimetypes_line = content.lines.find { |l| l.start_with?('MimeType=') }
    return [] unless mimetypes_line

    mimetypes_line.split('=').last.strip.split(';').map(&:strip).reject(&:empty?)
  end

  def clean_user_defaults
    return unless File.exist?(DEFAULTS_PATH)

    puts 'ðŸ§¹ Cleaning defaults.yaml of uninstalled applications...'
    config = YAML.load_file(DEFAULTS_PATH)
    defaults = config['Default Applications'] || {}

    cleaned_defaults, removed_count = _load_and_clean_defaults(defaults)

    puts "   Removed #{removed_count} obsolete entries." if removed_count.positive?

    config['Default Applications'] = cleaned_defaults.sort.to_h
    File.write(DEFAULTS_PATH, config.to_yaml.sub(/^---\n/, ''))
  end

  def _load_and_clean_defaults(defaults)
    original_count = defaults.size
    cleaned_defaults = defaults.select { |_mime, app| @available_apps.include?(app) }
    removed_count = original_count - cleaned_defaults.size
    [cleaned_defaults, removed_count]
  end

  def load_user_defaults
    return unless File.exist?(DEFAULTS_PATH)

    puts "âš™ï¸  Loading user defaults from #{DEFAULTS_PATH}..."
    defaults = YAML.load_file(DEFAULTS_PATH)['Default Applications'] || {}

    defaults.each do |key, value|
      if key.include?('*')
        @wildcard_defaults[key] = value
      else
        @exact_defaults[key] = value
      end
    end
  end

  def resolve_defaults
    puts 'ðŸ§  Resolving final default applications...'
    # 1. Apply wildcard defaults first
    @mimetype_to_apps.each_key do |mime|
      @wildcard_defaults.each do |pattern, app|
        @final_defaults[mime] = app if File.fnmatch(pattern, mime)
      end
    end

    # 2. Apply exact defaults, which will override any wildcard matches
    @final_defaults.merge!(@exact_defaults)
  end

  def write_output
    puts "âœï¸  Generating new #{File.basename(MIMEAPPS_OUTPUT_PATH)}..."
    output = []
    output << _generate_header
    output << _generate_default_applications_section(@final_defaults)
    output << _generate_added_associations_section(@mimetype_to_apps)

    File.write(MIMEAPPS_OUTPUT_PATH, "#{output.join("\n")}\n")
  end
end

# --- Run Script ---
MimeappsGenerator.new.run
